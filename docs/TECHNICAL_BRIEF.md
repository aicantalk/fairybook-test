# Fairybook Technical Brief

## Overview
Fairybook is a six-step Streamlit experience for building Korean children's stories with supporting artwork generated by Google Gemini. The UI in `app.py` manages session state across reruns, while `gemini_client.py` centralizes all Gemini prompt building and response handling. Static JSON assets provide reusable story archetypes, endings, and illustration styles that keep the interface lightweight and deterministic.

## UI Flow & Session State
- **Step 0 â€“ Mode selection**: Users choose between creating a new story or viewing saved exports. The helper `ensure_state()` seeds every session key once to avoid Streamlit rerun glitches.
- **Step 1 â€“ Audience & idea**: Form widgets write to transient keys (`age_input`, `topic_input`). Confirmed values are copied to `age` and `topic` only upon form submission.
- **Step 2 â€“ Story type & title**: Eight random archetypes from `storytype.json` feed the thumbnail picker. Once a type is confirmed, Gemini generates a title using that type's prompt.
- **Step 3 â€“ Cover preview**: The generated title immediately feeds cover-art creation, locks in the illustration style for the remainder of the session, and lets the user confirm before proceeding.
- **Step 4 â€“ Narrative card selection**: Four cards sampled from `story.json` steer the current stage. Users can re-sample cards or backtrack without losing the cover art or selected style.
- **Step 5 â€“ Stage results**: Gemini writes the requested stage using summaries of prior stages to maintain continuity while regenerating the illustration with the locked style. The UI now omits per-stage download buttons to keep the reading experience uncluttered.
- **Step 6 â€“ Saved story recap**: When all stages are complete, the full story appears with cover and stage separators plus a single HTML export action. The same viewer powers **ðŸ“‚ ì €ìž¥ë³¸ ë³´ê¸°** for past exports.

Key helpers such as `go_step()`, `list_html_exports()`, and `_build_story_html_document()` keep navigation and exporting predictable amid Streamlit reruns.

## Story Generation Pipeline
1. `generate_title_with_gemini()` builds a lightweight prompt from the age band, user topic, and selected story-type prompt to produce a JSON title payload.
2. After the cover preview, each narrative card triggers `generate_story_with_gemini()`, which now accepts the stage name/index plus summaries of previous stages so Gemini can weave consistent callbacks and emotional arcs.
3. The Gemini text model (`gemini-1.5-flash`) generates a response. `_extract_text_from_response()` tolerates both direct `.text` outputs and `candidates[0].content.parts` lists.
4. Markdown fences (```json) are stripped before `json.loads()` runs. Missing or malformed data produces a structured error message stored in `st.session_state["story_error"]`.
5. Successful results expose `title` and `paragraphs` fields back to the Streamlit layer for rendering; the UI no longer offers per-stage text downloads to keep users focused on reviewing the narrative.

## Illustration Pipeline
1. `build_image_prompt()` lazily loads `illust_styles.json`, caches the parsed list, and now honours a `style_override` so the cover's art direction is reused for every subsequent stage.
2. A directive prompt summarises the story (or individual stage), injects the style descriptor, and instructs Gemini to reply with a single English text prompt.
3. The cleaned prompt string feeds `generate_image_with_gemini()` which tries the configured image model followed by fallbacks (`imagen-3.0`, `imagen-3.0-light`).
4. `_extract_image_from_response()` normalises the various SDK response shapes, returning raw bytes and MIME type. Failures bubble up with descriptive copy surfaced in the UI.

## Data Assets
- **`storytype.json`** â€“ Card metadata (`id`, `name`, `prompt`, `illust`) used both for UX text and image thumbnails.
- **`story.json`** â€“ Storyline fragments and reusable beats to keep outputs on-theme.
- **`ending.json`** â€“ Optional ending templates the model may reference when crafting conclusions.
- **`illust_styles.json`** â€“ Named illustration styles; each entry contains `name` and `style` descriptors consumed by the prompt generator.

All JSON files are UTF-8 encoded and loaded lazily so Streamlit reruns stay responsive. When editing, maintain the existing schema to avoid breaking cached reads.

## Configuration & Environment
- `.env` holds `GEMINI_API_KEY` (required) and optional `GEMINI_IMAGE_MODEL`. Loading happens once on module import via `python-dotenv`.
- The default text model is `gemini-1.5-flash`; adjust `_MODEL` in `gemini_client.py` if latency or cost trade-offs change.
- Illustration fallbacks keep legacy Imagen endpoints working for older SDKs. Use `genai.list_models()` during development to verify availability before changing defaults.

## Error Handling & UX Feedback
- Missing secrets, empty JSON payloads, and Gemini safety blocks propagate as structured `{"error": ...}` dictionaries so the UI can surface localized Korean messages.
- HTML exports convert images to base64 data URIs, making each bundle self-contained. Filenames use a timestamp plus slugified title to prevent collisions.
- When illustration generation fails, the UI surfaces the prompt for debugging and encourages the user to retry before moving on; the locked style ensures later stages stay visually consistent once a cover is accepted.

## Extending the App
- **New archetypes or styles**: append entries to the respective JSON files and add matching thumbnails under `illust/` (512Ã—512 PNG recommended).
- **Alternative models**: update `_MODEL` or `_IMAGE_MODEL` constants, and keep fallbacks in sync with available endpoints.
- **Testing**: introduce `pytest` suites that mock `google.generativeai.GenerativeModel` and `ImageGenerationModel` to simulate responses without consuming quota.
- **Deployment**: ensure `.env` is managed securely (Streamlit Cloud secrets, environment variables, etc.) and write-protect `html_exports/` as needed for multi-user environments.

## Manual Verification Checklist
- Launch the app locally (headless or standard) and walk through Steps 0â€“6 using multiple story types and narrative cards.
- Confirm illustration thumbnails load from `illust/` and that the cover locks a style reused across all stages.
- Use **HTMLë¡œ ì €ìž¥** on the recap screen and validate the saved file opens correctly via the viewer.
- Restart the app to ensure session state resets gracefully while cached story assets persist.

For additional context or agent guidelines, see `AGENTS.md`.
