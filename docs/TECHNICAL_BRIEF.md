# Fairybook Technical Brief

## Overview
Fairybook is a two-step Streamlit experience for building Korean children's stories with supporting artwork generated by Google Gemini. The UI in `app.py` manages session state across reruns, while `gemini_client.py` centralizes all Gemini prompt building and response handling. Static JSON assets provide reusable story archetypes, endings, and illustration styles that keep the interface lightweight and deterministic.

## UI Flow & Session State
- **Step 0 – Mode selection**: Users choose between creating a new story or viewing saved exports. The helper `ensure_state()` seeds every session key once to avoid Streamlit rerun glitches.
- **Step 1 – Audience & idea**: Form widgets write to transient keys (`age_input`, `topic_input`). Confirmed values are copied to `age` and `topic` only upon form submission.
- **Step 2 – Story archetype**: Eight random cards from `storytype.json` populate the thumbnail picker. Selecting a card triggers story creation and illustration generation when the primary button is pressed. Results persist in session state for reruns.
- **Step 3 – Saved exports**: If HTML bundles exist in `html_exports/`, users can preview them inside an iframe or download copies. Navigation buttons reset the appropriate state slices without affecting cached assets.

Key helpers such as `go_step()`, `list_html_exports()`, and `_build_story_html_document()` keep navigation and exporting predictable amid Streamlit reruns.

## Story Generation Pipeline
1. `generate_story_with_gemini()` composes a strict JSON-only prompt via `_build_story_prompt()` using the confirmed age band, idea, and archetype name.
2. The Gemini text model (`gemini-1.5-flash`) generates a response. The client tolerates both direct `.text` outputs and `candidates[0].content.parts` lists.
3. Markdown fences (```json) are stripped before `json.loads()` runs. Missing or malformed data produces a structured error message stored in `st.session_state["story_error"]`.
4. Successful results expose `title` and `paragraphs` fields back to the Streamlit layer for rendering and downloads.

## Illustration Pipeline
1. `build_image_prompt()` lazily loads `illust_styles.json`, caches the parsed list, and randomly selects one style per invocation.
2. A directive prompt summarises the story, injects the style descriptor, and instructs Gemini to reply with a single English text prompt.
3. The cleaned prompt string feeds `generate_image_with_gemini()` which tries the configured image model followed by fallbacks (`imagen-3.0`, `imagen-3.0-light`).
4. `_extract_image_from_response()` normalises the various SDK response shapes, returning raw bytes and MIME type. Failures bubble up with descriptive copy surfaced in the UI.

## Data Assets
- **`storytype.json`** – Card metadata (`id`, `name`, `prompt`, `illust`) used both for UX text and image thumbnails.
- **`story.json`** – Storyline fragments and reusable beats to keep outputs on-theme.
- **`ending.json`** – Optional ending templates the model may reference when crafting conclusions.
- **`illust_styles.json`** – Named illustration styles; each entry contains `name` and `style` descriptors consumed by the prompt generator.

All JSON files are UTF-8 encoded and loaded lazily so Streamlit reruns stay responsive. When editing, maintain the existing schema to avoid breaking cached reads.

## Configuration & Environment
- `.env` holds `GEMINI_API_KEY` (required) and optional `GEMINI_IMAGE_MODEL`. Loading happens once on module import via `python-dotenv`.
- The default text model is `gemini-1.5-flash`; adjust `_MODEL` in `gemini_client.py` if latency or cost trade-offs change.
- Illustration fallbacks keep legacy Imagen endpoints working for older SDKs. Use `genai.list_models()` during development to verify availability before changing defaults.

## Error Handling & UX Feedback
- Missing secrets, empty JSON payloads, and Gemini safety blocks propagate as structured `{"error": ...}` dictionaries so the UI can surface localized Korean messages.
- HTML exports convert images to base64 data URIs, making each bundle self-contained. Filenames use a timestamp plus slugified title to prevent collisions.
- When illustration generation fails, the UI still offers text downloads and exposes the art prompt under an expander for debugging.

## Extending the App
- **New archetypes or styles**: append entries to the respective JSON files and add matching thumbnails under `illust/` (512×512 PNG recommended).
- **Alternative models**: update `_MODEL` or `_IMAGE_MODEL` constants, and keep fallbacks in sync with available endpoints.
- **Testing**: introduce `pytest` suites that mock `google.generativeai.GenerativeModel` and `ImageGenerationModel` to simulate responses without consuming quota.
- **Deployment**: ensure `.env` is managed securely (Streamlit Cloud secrets, environment variables, etc.) and write-protect `html_exports/` as needed for multi-user environments.

## Manual Verification Checklist
- Launch the app locally (headless or standard) and walk through Steps 0–2 using multiple story types.
- Confirm illustration thumbnails load from `illust/` and that at least one generated image renders in the UI.
- Use **HTML로 저장** and validate the saved file opens correctly via the Step 3 viewer.
- Restart the app to ensure session state resets gracefully while cached story types persist.

For additional context or agent guidelines, see `AGENTS.md`.
